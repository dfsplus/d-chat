"use strict";class Configs{constructor(s,e={syncKeys:[],logger:null}){this.$default=s,this._logging=e.logging||!1,this.$logger=e.logger,this._locked=new Set,this._lastValues={},this._observers=new Set,this._syncKeys=e.localKeys?Object.keys(s).filter(s=>!e.localKeys.includes(s)):e.syncKeys||[],this.$loaded=this._load()}async $reset(){this._applyValues(this.$default)}$addObserver(s){this._observers.has(s)||this._observers.add(s)}$removeObserver(s){this._observers.delete(s)}_log(s,...e){this._logging&&(s="Configs "+s,"function"===typeof this.$logger?this.$logger(s,...e):console.log(s,...e))}_load(){return this.$_promisedLoad||(this.$_promisedLoad=this._tryLoad())}async _tryLoad(){let s;this._log("load"),this._applyValues(this.$default);try{this._log("load: try load from storage on "+location.href);let[t,o,a]=await Promise.all([(async()=>{try{const s=await browser.storage.local.get(this.$default);return this._log("load: successfully loaded local storage"),s}catch(s){this._log("load: failed to load local storage: ",String(s))}return{}})(),(async()=>{if(!browser.storage.managed)return this._log("load: skip managed storage"),null;try{const s=await browser.storage.managed.get();return this._log("load: successfully loaded managed storage"),s||null}catch(s){this._log("load: failed to load managed storage: ",String(s))}return null})(),(async()=>{try{const s=await browser.runtime.sendMessage({type:"Configs:getLockedKeys"});return this._log("load: successfully synchronized locked state"),s||[]}catch(s){this._log("load: failed to synchronize locked state: ",String(s))}return[]})()]);this._log(`load: loaded for ${location.origin}:`,{localValues:t,managedValues:o,lockedKeys:a}),s=Object.assign({},t||{},o||{}),this._applyValues(s),this._log("load: values are applied"),o&&(a=a.concat(Array.from(Object.keys(o))));for(const s of a)this._updateLocked(s,!0);if(this._log("load: locked state is applied"),browser.storage.onChanged.addListener(this._onChanged.bind(this)),this._syncKeys||this._syncKeys.length>0)try{browser.storage.sync.get(this._syncKeys).then(s=>{if(this._log("load: successfully loaded sync storage"),s)for(const e of Object.keys(s))this[e]=s[e]})}catch(e){return this._log("load: failed to read sync storage: ",String(e)),null}return browser.runtime.onMessage.addListener(this._onMessage.bind(this)),s}catch(e){throw this._log("load: fatal error: ",e,e.stack),e}}_applyValues(s){for(const[e,t]of Object.entries(s))this._locked.has(e)||(this._lastValues[e]=t,e in this||Object.defineProperty(this,e,{get:()=>this._lastValues[e],set:s=>this._setValue(e,s)}))}_setValue(s,e){if(this._locked.has(s))return this._log(`warning: ${s} is locked and not updated`),e;if(JSON.stringify(e)==JSON.stringify(this._lastValues[s]))return e;this._log(`set: ${s} = ${e}`),this._lastValues[s]=e;const t={};t[s]=e;try{browser.storage.local.set(t).then(()=>{this._log("successfully saved",t)})}catch(o){this._log("save: failed",o)}try{this._syncKeys.includes(s)&&browser.storage.sync.set(t).then(()=>{this._log("successfully synced",t)})}catch(o){this._log("sync: failed",o)}return e}$lock(s){this._log("locking: "+s),this._updateLocked(s,!0)}$unlock(s){this._log("unlocking: "+s),this._updateLocked(s,!1)}$isLocked(s){return this._locked.has(s)}_updateLocked(s,e){e?this._locked.add(s):this._locked.delete(s),browser.runtime&&browser.runtime.sendMessage({type:"Configs:updateLocked",key:s,locked:this._locked.has(s)})}_onMessage(s,e){if(s&&"string"==typeof s.type)switch(this._log("onMessage: "+s.type,s,e),s.type){case"Configs:getLockedKeys":return Promise.resolve(Array.from(this._locked.values()));case"Configs:updateLocked":this._updateLocked(s.key,s.locked)}}_onChanged(s){for(const[e,t]of Object.entries(s))this._lastValues[e]=t.newValue,this.$notifyToObservers(e)}$notifyToObservers(s){for(const e of this._observers)"function"===typeof e?e(s):e&&"function"===typeof e.onChangeConfig&&e.onChangeConfig(s)}}